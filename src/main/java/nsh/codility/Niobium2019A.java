package nsh.codility;

import java.util.Arrays;
import java.util.Comparator;

public class Niobium2019A implements Niobium2019Interface {

	final long[] LONGBIT = new long[] { -9223372036854775808l, 4611686018427387904l, 2305843009213693952l,
			1152921504606846976l, 576460752303423488l, 288230376151711744l, 144115188075855872l, 72057594037927936l,
			36028797018963968l, 18014398509481984l, 9007199254740992l, 4503599627370496l, 2251799813685248l,
			1125899906842624l, 562949953421312l, 281474976710656l, 140737488355328l, 70368744177664l, 35184372088832l,
			17592186044416l, 8796093022208l, 4398046511104l, 2199023255552l, 1099511627776l, 549755813888l,
			274877906944l, 137438953472l, 68719476736l, 34359738368l, 17179869184l, 8589934592l, 4294967296l,
			2147483648l, 1073741824l, 536870912l, 268435456l, 134217728l, 67108864l, 33554432l, 16777216l, 8388608l,
			4194304l, 2097152l, 1048576l, 524288l, 262144l, 131072l, 65536l, 32768l, 16384l, 8192l, 4096l, 2048l, 1024l,
			512l, 256l, 128l, 64l, 32l, 16l, 8l, 4l, 2l, 1l };
	final long[] REMAINBIT = new long[] { 0l, -9223372036854775808l, -4611686018427387904l, -2305843009213693952l,
			-1152921504606846976l, -576460752303423488l, -288230376151711744l, -144115188075855872l,
			-72057594037927936l, -36028797018963968l, -18014398509481984l, -9007199254740992l, -4503599627370496l,
			-2251799813685248l, -1125899906842624l, -562949953421312l, -281474976710656l, -140737488355328l,
			-70368744177664l, -35184372088832l, -17592186044416l, -8796093022208l, -4398046511104l, -2199023255552l,
			-1099511627776l, -549755813888l, -274877906944l, -137438953472l, -68719476736l, -34359738368l,
			-17179869184l, -8589934592l, -4294967296l, -2147483648l, -1073741824l, -536870912l, -268435456l,
			-134217728l, -67108864l, -33554432l, -16777216l, -8388608l, -4194304l, -2097152l, -1048576l, -524288l,
			-262144l, -131072l, -65536l, -32768l, -16384l, -8192l, -4096l, -2048l, -1024l, -512l, -256l, -128l, -64l,
			-32l, -16l, -8l, -4l, -2l };

	public int solution(int[][] A) {
		int N = A.length;
		if (N == 1)
			return 1;

		int M = A[0].length;
		int LONGSIZE = M / 64;
		int REMAIN = M % 64;
		if (REMAIN > 0)
			LONGSIZE++;
		long L[][] = new long[N][LONGSIZE];
		for (int i = 0; i < N; i++) {
			boolean flip = (A[i][0] == 1);
			for (int j = 0, m = 0; j < LONGSIZE; j++) {
				long l = 0;
				for (int k = 0; k < 64 && m < M; k++, m++) {
					int a = A[i][m];
					if (a == 1)
						l |= LONGBIT[k];
				}
				L[i][j] = flip ? ~l : l;
			}
			if (REMAIN > 0)
				L[i][LONGSIZE - 1] = L[i][LONGSIZE - 1] & REMAINBIT[REMAIN];
		}

		Arrays.sort(L, new Comparator<long[]>() {

			@Override
			public int compare(long[] o1, long[] o2) {
				int i = 0;
				while (i < o1.length) {
					if (o1[i] != o2[i])
						return (o1[i] < o2[i]) ^ (o1[i] < 0) ^ (o2[i] < 0) ? 1 : -1;
					i++;
				}
				return 0;
			}
		});

		int R = 0;
		int C = 1;
		int lastN = 0;
		for (int i = 1; i < N; i++) {
			boolean same = true;
			for (int j = 0; j < LONGSIZE; j++)
				if (L[i][j] != L[lastN][j]) {
					same = false;
					break;
				}

			if (same)
				C++;
			else {
				R = Math.max(R, C);
				C = 1;
				lastN = i;
			}
		}
		R = Math.max(R, C);

		return R;
	}
}
